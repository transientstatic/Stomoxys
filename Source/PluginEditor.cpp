/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
SenselVapbiAudioProcessorEditor::SenselVapbiAudioProcessorEditor (SenselVapbiAudioProcessor& p)
    : AudioProcessorEditor (&p), processor (p)
{
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    const OwnedArray<AudioProcessorParameter>& params = p.getParameters();
    //immediately split them...
    
    //For testing, the first param, is choice
    for (int ii = 0; ii < params.size() - numCombos; ++ii) {
        if (const AudioParameterFloat* param = dynamic_cast<AudioParameterFloat*> (params[ii])) {
            Slider* aSlider;
            
            paramSliders.add (aSlider = new Slider (param->name));
            aSlider->setRange (param->range.start, param->range.end);
            aSlider->setSliderStyle (Slider::LinearHorizontal);
            aSlider->setSkewFactor(param->range.skew, param->range.symmetricSkew);
            aSlider->setValue (*param);
            
            aSlider->addListener (this);
            addAndMakeVisible (aSlider);
            
            Label* aLabel;
            paramLabels.add (aLabel = new Label (param->name, param->name));
            addAndMakeVisible (aLabel);
        }
    }
    
    noParameterLabel.setJustificationType (Justification::horizontallyCentred | Justification::verticallyCentred);
    noParameterLabel.setFont (noParameterLabel.getFont().withStyle (Font::italic));
    
    //==============================================================================
    
    
    for (int ii = paramSliders.size(); ii < params.size(); ++ii) {
        if (const AudioParameterChoice* param = dynamic_cast<AudioParameterChoice*> (params[ii])) {
            ComboBox* aComboBox;
            
            paramCombos.add (aComboBox = new ComboBox (param->name));
            aComboBox->setEditableText (false);
            aComboBox->setJustificationType (Justification::centredLeft);
            aComboBox->setTextWhenNothingSelected (String::empty);
            aComboBox->setTextWhenNoChoicesAvailable ("(no choices)");
            aComboBox->addItemList(param->choices, 1);
            aComboBox->setSelectedItemIndex(param->getIndex());
            aComboBox->addListener (this);
            addAndMakeVisible (aComboBox);
            
            Label* aLabel;
            paramComboLabels.add (aLabel = new Label (param->name, param->name));
            addAndMakeVisible (aLabel);
        }
    }
    
    noParameterLabel.setJustificationType (Justification::horizontallyCentred | Justification::verticallyCentred);
    noParameterLabel.setFont (noParameterLabel.getFont().withStyle (Font::italic));
    
    //==============================================================================
    
    addAndMakeVisible (vstDataConsole = new TextEditor ("console for vst data"));
    vstDataConsole->setMultiLine (true);
    vstDataConsole->setReturnKeyStartsNewLine (true);
    vstDataConsole->setReadOnly (true);
    vstDataConsole->setScrollbarsShown (true);
    vstDataConsole->setCaretVisible (false);
    vstDataConsole->setPopupMenuEnabled (false);
    vstDataConsole->setText (String::empty);
    
    addAndMakeVisible (vstMsgConsole = new TextEditor ("console for vst status"));
    vstMsgConsole->setMultiLine (true);
    vstMsgConsole->setReturnKeyStartsNewLine (true);
    vstMsgConsole->setReadOnly (true);
    vstMsgConsole->setScrollbarsShown (true);
    vstMsgConsole->setCaretVisible (false);
    vstMsgConsole->setPopupMenuEnabled (false);
    vstMsgConsole->setText (String::empty);

    //NEED TO BLEND THESE TWO TOGETHER
    if ((kParamSliderWidth + kParamLabelWidth) > (2*kConsoleWidth)){
        setSize (kParamSliderWidth + kParamLabelWidth,
                 kConsoleHeight + jmax (1, kParamControlHeight * (paramSliders.size()+paramCombos.size())));
    } else {
        setSize (2*kConsoleWidth,
                 kConsoleHeight + jmax (1, kParamControlHeight * (paramSliders.size()+paramCombos.size())));
    }
    
    startTimer(100);

}

SenselVapbiAudioProcessorEditor::~SenselVapbiAudioProcessorEditor()
{
    vstDataConsole = nullptr;
    vstMsgConsole = nullptr;
}

//==============================================================================
void SenselVapbiAudioProcessorEditor::paint (Graphics& g)
{
//    g.fillAll (Colours::white);

    g.setColour (Colours::red);
    g.setFont (15.0f);
    g.fillRect (getLocalBounds());
}

void SenselVapbiAudioProcessorEditor::resized()
{
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
    //need to get these to play happy.
    
    Rectangle<int> r = getLocalBounds();
    
    Rectangle<int> consoleBounds = r.removeFromTop(kConsoleHeight);
    Rectangle<int> msgConsoleBounds = consoleBounds.removeFromLeft(kConsoleWidth);
    
    vstMsgConsole->setBounds (msgConsoleBounds);
    vstDataConsole->setBounds (consoleBounds); //should be what remains
    
    //want combo boxes pre sliders
    for (int ii = 0; ii < paramCombos.size(); ++ii)
    {
        Rectangle<int> paramBounds = r.removeFromTop (kParamControlHeight);
        Rectangle<int> labelBounds = paramBounds.removeFromLeft (kParamLabelWidth);
        
        paramComboLabels[ii]->setBounds (labelBounds);
        paramCombos[ii]->setBounds (paramBounds);
        paramComboLabels[ii]->setColour(juce::Label::textColourId, juce::Colours::whitesmoke);
    }
    
    for (int ii = 0; ii < paramSliders.size(); ++ii)
    {
        Rectangle<int> paramBounds = r.removeFromTop (kParamControlHeight);
        Rectangle<int> labelBounds = paramBounds.removeFromLeft (kParamLabelWidth);
        
        paramLabels[ii]->setBounds (labelBounds);
        paramSliders[ii]->setBounds (paramBounds);
        paramLabels[ii]->setColour(juce::Label::textColourId, juce::Colours::whitesmoke);
    }
    
}


void SenselVapbiAudioProcessorEditor::timerCallback()
{
    
    VST_Console_String * consoleUpdateMsg = processor.getConsoleMsg();
    VST_Console_String * consoleUpdateData = processor.getConsoleData();

    
//will this repaint when tab shows?
    if ((consoleUpdateMsg != nullptr) && (consoleUpdateMsg->mSendFlag)){
        String oldText = vstMsgConsole->getText();
        if (oldText.length() > 750){    //somewhat small limit of 750 old characters
            oldText = oldText.substring(oldText.length() - 750);
        }
        vstMsgConsole->setText(oldText + consoleUpdateMsg->mMsg);
        consoleUpdateMsg->clear();
        consoleUpdateMsg->mSendFlag = false;
        vstMsgConsole->moveCaretToEnd(); //I think this will show me the most recent text?
    }
    //will this repaint when tab shows?
    if ((consoleUpdateData != nullptr) && (consoleUpdateData->mSendFlag)){
        String oldText = vstDataConsole->getText();
        if (oldText.length() > 750){    //somewhat small limit of 750 old characters
            oldText = oldText.substring(oldText.length() - 750);
        }
        vstDataConsole->setText(oldText + consoleUpdateData->mMsg);
        consoleUpdateData->written();
        vstDataConsole->moveCaretToEnd(); //I think this will show me the most recent text?
    }
    
    const OwnedArray<AudioProcessorParameter>& params = getAudioProcessor()->getParameters();
    
    for (int i = 0; i < (params.size() - numCombos); ++i) {
        if (const AudioParameterFloat* param = dynamic_cast<AudioParameterFloat*> (params[i])) {
            if (i < paramSliders.size())
                paramSliders[i]->setValue (*param);
        }
    }
    
    for (int i = (params.size() - numCombos); i < params.size(); ++i) {
        if (const AudioParameterChoice* param = dynamic_cast<AudioParameterChoice*> (params[i])) {
            if (i < paramCombos.size())
                paramCombos[i]->setSelectedItemIndex(*param);
        }
    }

}
