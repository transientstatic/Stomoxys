/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

//#include "oscpkt.hh"
//#include "udp.hh"

#include <functional>
#include <iomanip> //setw


#define SENSOR_OSC_ADDRESS "127.0.0.1" //This is the local machine
#define SENSOR_OSC_PORT 8000
#define SENSOR_OSC_OUTPUT_BUFFER_SIZE 1024

#define OSC_REMOTE_ADDRESS "localhost"
#define OSC_LOCAL_PORT  7560
#define OSC_REMOTE_PORT 7562

using namespace std;

const bool gDebug_logging = true;  //

#define SIZE_DATA_AUDIO_BLOCK 128
#define MAX_FUND_FREQ_PLATE   80.0f

#include<random>
#include<array>

static const int Test_User_Seed[] = {8797, 8178, 2608, 5944, 226, 4253, 3128, 1615, 1788, 8148, 4229, 976, 1577, 1419, 6558};
const int* mTestUserSeeds = Test_User_Seed;

//Will need to fix this so that it is dynamic, should have some examples from Bela but for now... no worries.
#define PUNKS_MAC_LOGGING_DIRECTORY "/Users/punk/QUB/SenselVapbiSend/Logs"
#define PANDA_MAC_LOGGING_DIRECTORY "/Users/panda03/Desktop/Logs"

enum Verbose_Level{
    kSilent_Verbose = 0,    //no stream out
    kStream_Verbose = 1,    //light data logging- core stream once only
    kUnique_Verbose = 2,    //use this for specialized debugging- only get this out.
    kData_Verbose,            //log data
    kDebug_Verbose,            //enables file debugging in log
    kExceedingly_Verbose,    //there are times when I have stuff that happens a lot and don't necessarily want to allow normally
    kConsole_Verbose        //enables text to the console (note, no other logging- I haven't coded to support this...)
};

enum Trial_Conditions{
    kSummed_NonLinear = 0,    //no stream out
    kAve_NonLinear,
    kInverse_NonLinear,
    kSummed_Linear,            //log data
    kAve_Linear,
    kInverse_Linear,
    kNumConditions
};

//diverges from MAX's version because I want mine limited
static inline float scale(const float inVal, const float inMin, const float inMax, const float outMin, const float outMax){
    float outval = (outMax-outMin)/(inMax-inMin);
    if (outval < 0.f){
        outval = outMax + inVal*outval;
    } else {
        outval = outMin + inVal*outval;
    }
    if (outval > outMax) outval = outMax;
    if (outval < outMin) outval = outMin;
    return outval;
}

//inMin and inMax are the normal inMin and inMax, because I want constant decay rate...
static inline float ramp(const float inVal, const float decayLen, const float inMin, const float inMax){
    float delta = (inMax-inMin)/decayLen;
    float outval = inVal;
    if (delta > 0.f){
        if (inVal > inMin) outval -= delta;
        if (outval < inMin) outval = inMin;
    } else {
        if (inVal < inMin) outval -= delta;
        if (outval > inMin) outval = inMin;
    }
    return outval;
}

//==============================================================================
//              ADDED BY ME
//==============================================================================

void SenselVapbiAudioProcessor::getTrialOrder(const int inUserNum){
    //Random ordering of settings
    std::default_random_engine gen;
    gen.seed(Test_User_Seed[inUserNum]);
    std::uniform_int_distribution<int> dist(0,NUM_TEST_CONDITIONS-1);
    
    std::array<int, NUM_TEST_CONDITIONS> tcase;
    
    for (int j = 0; j < 2; j++){
        for (int i = 0; i < NUM_TEST_CONDITIONS; i++){
            int tmpC[] = {1,1,1,1,1,1};
            int cnt = 0;
            while (cnt < NUM_TEST_CONDITIONS) {
                int theCase = dist(gen);
                if (tmpC[theCase]){
                    tcase[cnt++] = theCase;
                    tmpC[theCase] = 0;
                }
            }
        }
        if (j == 0){
            trialOneSettings = tcase;
        } else {
            trialThreeSettings = tcase;
        }
    }
        //print t-case
    mVSTConsoleMsg.add(String("Set for participant number ") + String(inUserNum+1) + String("\n"));
    mVSTConsoleMsg.add(String("Session One order is: "));
    for (int i = 0; i < NUM_TEST_CONDITIONS - 1; i++){
        mVSTConsoleMsg.add(String(trialOneSettings[i]+1)+ String(", "));
    }
    mVSTConsoleMsg.add(String(trialOneSettings[NUM_TEST_CONDITIONS-1]+1)+ String("\n"));
    mVSTConsoleMsg.add(String("Session Three order is: "));
    for (int i = 0; i < NUM_TEST_CONDITIONS - 1; i++){
        mVSTConsoleMsg.add(String(trialThreeSettings[i]+1)+ String(", "));
    }
    mVSTConsoleMsg.write(String(trialThreeSettings[NUM_TEST_CONDITIONS-1]+1)+ String("\n"));
}

void SenselVapbiAudioProcessor::getTrialState(const int inTrialNum){
    int trial = -1;
    if (*sessionNumParam == 0){ //this bit is zero indexed
        trial = trialOneSettings[inTrialNum];
        mEffort = 0.51f;
        mAveEffort = 10.0f;
    } else {
        trial = trialThreeSettings[inTrialNum];
        mEffort = 0.38f;
        mAveEffort = 6.5f;
    }
    
    mVSTConsoleMsg.add(String("Session One order is: "));
    for (int i = 0; i < NUM_TEST_CONDITIONS - 1; i++){
        mVSTConsoleMsg.add(String(trialOneSettings[i]+1)+ String(", "));
    }
    mVSTConsoleMsg.add(String(trialOneSettings[NUM_TEST_CONDITIONS-1]+1)+ String("\n"));

    switch (trial) {
        case kSummed_NonLinear :
            *dampStyleParam = kSumForce;
            *freqStyleParam = kSumForce;
            mVSTConsoleMsg.add("\n Set to Summed Force Non-Linear.  Set Vapbi for Condition 1.\n");
            break;
        case kAve_NonLinear :
            *dampStyleParam = kAveForce;
            *freqStyleParam = kAveForce;
            mVSTConsoleMsg.write("\n Set to Ave Force Non-Linear.  Set Vapbi for Condition 1.\n");
            break;
        case kInverse_NonLinear :
            *dampStyleParam = kInverseForce;
            *freqStyleParam = kInverseForce;
            mVSTConsoleMsg.write("\n Set to Inverse Force Non-Linear.  Set Vapbi for Condition 1.\n");
            break;
        case kSummed_Linear :
            *dampStyleParam = kSumForce;
            *freqStyleParam = kSumForce;
            mVSTConsoleMsg.write("\n Set to Summed Force Linear.  Set Vapbi for Condition 2.\n");
            break;
        case kAve_Linear :
            *dampStyleParam = kAveForce;
            *freqStyleParam = kAveForce;
            mVSTConsoleMsg.write("\n Set to Ave Force Linear.  Set Vapbi for Condition 2.\n");
            break;
        case kInverse_Linear :
            *dampStyleParam = kInverseForce;
            *freqStyleParam = kInverseForce;
            mVSTConsoleMsg.write("\n Set to Inverse Force Linear.  Set Vapbi for Condition 2.\n");
            break;
    }
    mLogFile << "[PID, " << *participantNumParam << " SID, " << *sessionNumParam << " TID, " << *trialNumParam + 1 << "]\n";
}

void SenselVapbiAudioProcessor::updateTrialInfo(void){
    if (*participantNumParam != prevParticipantNum){
        prevParticipantNum = *participantNumParam;
        getTrialOrder(prevParticipantNum);
        getTrialState(*trialNumParam);
        prevTrialNum = *trialNumParam;
    }
    if (*sessionNumParam!= prevSessionNum) {
        prevSessionNum = *sessionNumParam;
        getTrialState(*trialNumParam);
        prevTrialNum = *trialNumParam;
    }
    if (*trialNumParam != prevTrialNum){
        prevTrialNum = *trialNumParam;
        getTrialState(prevTrialNum);
    }
}

bool SenselVapbiAudioProcessor::openLogFile(){
    
    //close any existing logfile and start a new one
    
    if (mLogFile.is_open()){
        mLogFile.close();
    }
    
    Time rtime = Time::getCurrentTime();
    
    char filename[80];
    
    sprintf(filename, "%s/sensel-%d-%d-%02d%02d.%d.txt", PUNKS_MAC_LOGGING_DIRECTORY, rtime.getMonth(), rtime.getDayOfMonth(), rtime.getHours(), rtime.getMinutes(),rtime.getSeconds());
    mLogFile.open (filename);
    mLogFile << std::setw(10);
    
    if (mLogFile.is_open()){
        mVSTConsoleMsg.add(String("Log file opened to ")+String(filename)+String("\n"));
    } else {
        sprintf(filename, "%s/sensel-%d-%d-%02d%02d.%d.txt", PANDA_MAC_LOGGING_DIRECTORY, rtime.getMonth(), rtime.getDayOfMonth(), rtime.getHours(), rtime.getMinutes(),rtime.getSeconds());
        mLogFile.open (filename);
        if (mLogFile.is_open()){
            mVSTConsoleMsg.add(String("Log file opened to ")+String(filename)+String("\n"));
        } else {
            mVSTConsoleMsg.add(String("Opening Log File Failed :( .\n"));
        }
    }

    if (mVerbose >= kDebug_Verbose) {
        mLogFile << "File Open Attempted.\n";
    }
    
//    mVSTConsoleMsg.add(String("v.3\n"));
//    mVSTConsoleMsg.write(String("The max value of any parameter is limited to vapbi defaults.\n"));
    return mLogFile.is_open();
    
}

//==============================================================================

void SenselVapbiAudioProcessor::hiResTimerCallback()
{
    
    //==============================================================================
    //parameter updates:
    //==============================================================================
    
    minSigma0 = *sigma0_plate;
    mSigma0Range = *sigma0_plate_range;
//    mEffort = *sigma0_plate_range;  //temp hijack
    minSigma1 = *sigma1_plate;
    mSigma1Range = *sigma1_plate_range;
    minf1_plate = *f1_plate;
    mF1_plateRange = *f1_plate_range;
    
    int dampStyle = dampStyleParam->getIndex();
    if (dampStyle != prevDampStyle){
        switch (dampStyle){
            case kSumForce :
                mVSTConsoleMsg.write("Switching Damping to SUM of Force.\n");
                break;
            case kAveForce  :
                mVSTConsoleMsg.write("Switching Damping to AVERAGE of Force.\n");
                break;
            case kInverseForce :
                mVSTConsoleMsg.write("Switching Damping to INVERSE SUM of Force.\n");
                break;
            case kOff :
            default   :
                mVSTConsoleMsg.write("Switching Damping off.\n");
        }
        prevDampStyle = dampStyle;
    }
    
    int freqStyle = freqStyleParam->getIndex();
    if (freqStyle != prevFreqStyle){
        switch (freqStyle){
            case kSumForce :
                mVSTConsoleMsg.write("Switching Frequency Bending to SUM of Force.\n");
                break;
            case kAveForce  :
                mVSTConsoleMsg.write("Switching Frequency Bending to AVERAGE of Force.\n");
                break;
            case kInverseForce :
                mVSTConsoleMsg.write("Switching Frequency to INVERSE SUM of Force.\n");
                break;
            case kOff :
            default   :
                mVSTConsoleMsg.write("Switching Frequency Bending off.\n");
        }
        prevFreqStyle = freqStyle;
    }

    
    AudioPlayHead::CurrentPositionInfo trackState;
    chrono::milliseconds ms;
    int32 approxSamplesSinceAudioProcessing = 0;
    
    AudioPlayHead* playhead = getPlayHead();
    playhead->getCurrentPosition(trackState);
    
    float normalisedTimeStamp = (trackState.timeInSamples % ((int) 2.0*44100))/(2.f*44100);
    mOscSend.newMessage("/sensel").add((float)normalisedTimeStamp).send();

    //update the sensel parameters
    //think I need to add something to make sure this has finished before we try to delete.
    for (auto sensel : sensels)
    {
        
        /*
        mHpDampCutoff = hpDampCutParam->get();
        sensel->mHPDampThreshold = mHpDampCutoff;

        mLpDampCutoff = lpDampCutParam->get();
        sensel->mLPDampThreshold = mLpDampCutoff;

        int senselSampleRate = sensel->getSampleRate();
        if (mLpF0 != lpF0Param->get()){
            if (lpF0Param->get() <= 50.0) {
                sensel->setLP_F0(lpF0Param->get()/senselSampleRate);
            } else {
                sensel->setLPCoefs({0.097631, 0.195262, 0.097631, -0.942809, 0.333333}); // Original ones
                mLpF0 = lpF0Param->get();
            }
        }
        if (mHpF0 != hpF0Param->get()){
            if (hpF0Param->get() <= 50.0){
                sensel->setHP_F0(hpF0Param->get()/senselSampleRate);
            } else {
                sensels[0]->setHPCoefs({0.569036, -1.138071, 0.569036, -0.942809, 0.333333});
                mHpF0 = hpF0Param->get();
            }
        }

         if (mLpQ != lpQParam->get()){
            sensel->setLP_Q(lpQParam->get());
        }
        if (mHpQ != hpQParam->get()){
            sensel->setHP_Q(hpQParam->get());
        }
 */
        //Putting this inside the lock massively impedes performance on the receive.  Don't, but keep it close to the time update
        bool sensel_ok = sensel->check(); //pretty sure this will not fix...
        
        int64 timestamp;
        {  //locked section.
            std::lock_guard<std::mutex> lockGuard(block);

            chrono::steady_clock::time_point nowtime = std::chrono::steady_clock::now();
            ms = std::chrono::duration_cast<std::chrono::milliseconds>(nowtime - dataTimer);
            dataTimer = nowtime;
            
            chrono::microseconds usecSinceAudioProcessing = std::chrono::duration_cast<std::chrono::microseconds>(nowtime - audioTimer);

            //adding this to the sample time from the last audio processing block works pretty well
            approxSamplesSinceAudioProcessing = usecSinceAudioProcessing.count()*44100*1e-6;
            if (approxSamplesSinceAudioProcessing > mSampleBlockSize) approxSamplesSinceAudioProcessing = mSampleBlockSize - 1;
             timestamp= localTimeInSamples+approxSamplesSinceAudioProcessing;
        }
        
        if (!sensel_ok){
            mVSTConsoleData.write(String("Reading Sensel Failed \n"));
            continue;  //skip the rest of the for loop.
        };

        if (sensel->numFrames == 0) mNumMissedFrames++;
        
        int strikeID = -1; //ID of any strike found within the frame.  -1 if nothing found

        for (int i = 0; i < sensel->numFrames; i++){

            unsigned int fingerCount = sensel->activeContacts.size(); //limited to number registered

            Sensel_Vapbi_Data senselData;
            senselData.timestamp = localTimeInSamples+approxSamplesSinceAudioProcessing;
            
//            mOscSend.newMessage("/sensel").add((float)(trackState.timeInSamples % 88200)/88200.0f);//.add((int)fingerCount);
            
            //want to debug print these
            float aveForce = 0.f;
            float forceSum = 0.f;
            float areaSum = 0.f;

            if (fingerCount > 0){ //only update if senselData going.
                //if fingerCount > 0 these are guaranteed to be non-zero

                //Dampening section- same as MAX except for scaling.
                //currently does not include strikes, but can remove obviously if preferred.
                for (int c = 0; c < sensel->activeContacts.size(); c++){ //I think this includes one ending.  Is that signalling it has finished?
//                    if (sensel->fingers[sensel->activeContacts[c]].isDamp) {
                        areaSum += sensel->fingers[sensel->activeContacts[c]].area;
                        forceSum += sensel->fingers[sensel->activeContacts[c]].force;
                    }
//                }

                aveForce = forceSum/areaSum;
                if (isnan(aveForce)) aveForce = 0.;
                
                float effeSigma0Max = ((minSigma0+mSigma0Range) < 1.0f) ? (minSigma0+mSigma0Range) : 1.0f;
                float effeSigma1Max = ((minSigma1+mSigma1Range) < 1.0f) ? (minSigma1+mSigma1Range) : 1.0f;
                
                switch (dampStyle){
                    case kSumForce :
                        senselData.sigma0Plate = scale(forceSum, 0.0f, mEffort, minSigma0, effeSigma0Max);
                        senselData.sigma1Plate = scale(forceSum, 0.0f, mEffort, minSigma1, effeSigma1Max);
                        break;
                    case kInverseForce :
                        //These lines should have been:
//                        senselData.sigma0Plate = scale(forceSum, mEffort, 0.f, minSigma0, effeSigma0Max);
                        
                        senselData.sigma0Plate = scale(forceSum, mEffort, 0.f, (minSigma0 + 1.0-effeSigma0Max), 1.0f);
//                        senselData.sigma1Plate = scale(forceSum, mEffort, 0.f, (minSigma1 + 1.0-effeSigma1Max), 1.0f); //this is probably not what we want but....;
                        senselData.sigma1Plate = scale(forceSum, mEffort, 0.f, minSigma1, effeSigma1Max);
                        if (senselData.sigma0Plate > 1.0) senselData.sigma0Plate = 1.0f;
                        if (senselData.sigma1Plate > 1.0) senselData.sigma1Plate = 1.0f;
                        break;
                    case kAveForce  :
                        senselData.sigma0Plate = scale(aveForce, 0.0f, mAveEffort, minSigma0, effeSigma0Max);
                        senselData.sigma1Plate = scale(aveForce, 0.0f, mAveEffort, minSigma1, effeSigma1Max);
                        break;
                    case kOff :
                    default   :
                        senselData.sigma0Plate = minSigma0;
                        senselData.sigma1Plate = minSigma1;
                }

                //calc freq deviation
                //             fn = forig/2^(xcents/(-12))
                //F1 Min is (and must be) capped at an octave below vapbi 160F max in order for the below to not piss off vapbi.
                float centsBend = 0.f;
                switch (freqStyle){
                    case kSumForce :
                        centsBend = scale(forceSum, 0.0f, mEffort, 0.0f, mF1_plateRange);
                        break;
                    case kInverseForce :
                        centsBend = scale(forceSum, mEffort, 0.f, 0.0f, mF1_plateRange);
                        break;
                    case kAveForce  :
                        centsBend = scale(aveForce, 0.0f, mAveEffort, 0.0f, mF1_plateRange);  //because F1 Min is capped at
                        break;
                    case kOff :
                    default   :
                        centsBend = 0.f;
                }
                float shiftedFreq = minf1_plate/(powf(2.0, (centsBend/-12.0f)));
                senselData.fundFreqPlate = shiftedFreq;
                
                mOscSend.newMessage("/forceSum").add((float)(forceSum)).send();
                mOscSend.newMessage("/ave").add((float)(aveForce)).send();
                mOscSend.newMessage("/sigma0Plate").add((float)(senselData.sigma0Plate)).send();

                //end dampening
                
                //this needs to be updated.
                //what do I want to do as my damp threshold? could do a combo of low and high, but lets just do high (same as Miguel)
                std::vector<float> potentialStrikes;
                for (int c = 0; c < sensel->activeContacts.size(); c++){ //I think this includes one ending.  Is that signalling it has finished?
                    if (!sensel->fingers[sensel->activeContacts[c]].isDamp){
                        potentialStrikes.push_back(sensel->activeContacts[c]);
                    }
                }
                //typically should only get one at a time, but if this doesn't happen, look for the one with the highest force
                
                //need to track old value so that if strike ID is -1, we don't update x,y
                if (potentialStrikes.size() > 0){
                    float maxForce = sensel->fingers[potentialStrikes[0]].force; //do I want to use hp? lets try this first
                    strikeID = potentialStrikes[0];
                    for (int c = 1; c < potentialStrikes.size(); c++){
                        if (sensel->fingers[potentialStrikes[c]].force > maxForce) {
                            maxForce = sensel->fingers[potentialStrikes[c]].force;
                            strikeID = potentialStrikes[c];
                        }
                    }
                    senselData.xr1_excitation = sensel->fingers[strikeID].x;
                    senselData.yr1_excitation = sensel->fingers[strikeID].y;
                } else {
                    senselData.xr1_excitation = lastSenselData.xr1_excitation;
                    senselData.yr1_excitation = lastSenselData.yr1_excitation;
                }
                mSenselData.push_back(senselData);
                lastSenselData = senselData;
                //if (fingerCount > 0){ Now //deal with damping back to zero
            } else {
                bool send = false;
                float maxShift = minf1_plate/(powf(2.0, (mF1_plateRange/-12.0f)));
                senselData.fundFreqPlate = (freqStyle != kInverseForce) ? minf1_plate : maxShift; //set default
                if (dampStyle != kInverseForce) {  //don't care about range here...
                    senselData.sigma0Plate = minSigma0;
                    senselData.sigma1Plate = minSigma1;
                    if ((lastSenselData.sigma0Plate > minSigma0) || (lastSenselData.sigma1Plate > minSigma1)) {
                        senselData.sigma0Plate = ramp(lastSenselData.sigma0Plate,  50, minSigma0, 1.0f);
                        senselData.sigma1Plate = ramp(lastSenselData.sigma1Plate, 50, minSigma1, 1.0f);
                        send = true;
                    }
                } else {
                    senselData.sigma0Plate = minSigma0 + mSigma0Range;
                    senselData.sigma1Plate = minSigma1 + mSigma1Range;
                    if ((lastSenselData.sigma0Plate < 1.0f) || (lastSenselData.sigma1Plate < 1.0f)) {
                        senselData.sigma0Plate = ramp(lastSenselData.sigma0Plate,  50, 1.0f, minSigma0);
                        senselData.sigma1Plate = ramp(lastSenselData.sigma1Plate, 50, 1.0f, minSigma1);
                        send = true;
                    }
                }
                if ((freqStyle != kInverseForce) && (lastSenselData.fundFreqPlate > minf1_plate)) {
                    senselData.fundFreqPlate = ramp(lastSenselData.fundFreqPlate, 50, minf1_plate, maxShift);
                    send = true;
                }
                if ((freqStyle == kInverseForce) && (lastSenselData.fundFreqPlate < maxShift)) {
                    senselData.fundFreqPlate = ramp(lastSenselData.fundFreqPlate, 50, maxShift, minf1_plate);
                    send = true;
                }
                
                if (send) {
                    senselData.xr1_excitation = lastSenselData.xr1_excitation;
                    senselData.yr1_excitation = lastSenselData.yr1_excitation;
                    
                    mSenselData.push_back(senselData);
                    lastSenselData = senselData;
                }
            }

            if (!(numSenselSamples%20)){
                mVSTConsoleData.add(String("#C: ") + String(fingerCount)+ String("  "));// + String() + String(", ") + String(untaintedForce) + String(" : "));
                for (int i = 0; i < fingerCount; i++) {
                    int f = sensel->activeContacts[i];
                    mVSTConsoleData.add(String(sensel->fingers[f].fingerID) + String(":") + String(sensel->fingers[f].lp.current()) + String(", ") + String(sensel->fingers[f].hp.current()));
                }
//                String(sensel->fingers[f].state)+String(":") +
                mVSTConsoleData.write(String("\n"));

            }

        }
        
        if (mlogEnabled){ //start log entry
            
            //Let's get the playback sample time
            //Stamp sample position
            AudioPlayHead* track = getPlayHead();
            track->getCurrentPosition(trackState);
            
            unsigned int fingerCount = sensel->contactAmount;

//            mLogFile << "[S] S: " << trackState.timeInSamples << " PBT: " << localTimeInSamples + approxSamplesSinceAudioProcessing << " DT: " << ms.count() << " F: " << sensel->numFrames << " #MF: " << mNumMissedFrames;
  
            mLogFile << "[" << trackState.timeInSamples << ", " << localTimeInSamples + approxSamplesSinceAudioProcessing << ", " << fingerCount << ", " <<  strikeID << "]";
            //for damp vs tap, always log 6
//            for (int f = 0; f < 6; f++) {
            for (int f = 0; f < 16; f++) { //logging first 6 contacts
//               if (int )
                if (sensel->fingers[f].state != CONTACT_END) {
                    mLogFile << "[" << sensel->fingers[f].fingerID ;
                    mLogFile << ", " << sensel->fingers[f].x << ", " << sensel->fingers[f].y << ", " << sensel->fingers[f].force << ", " << sensel->fingers[f].area << "]";
                } else {
                    mLogFile << "[-1, " << 0.f << ", " << 0.0 << ", " << 0.f << ", " << 0.f << "]";
                }
        }

//            mOscSend.send(); //this shouldn't be in the lock...
        }
        mLogFile << "\n";
             
    }
    //    cout << "Time: " << ms.count() << "\n";
}

//==============================================================================

void SenselVapbiAudioProcessor::parseMessage(oscpkt::Message *msg, void* arg){
    std::cout << "received: %s\n", msg->addressPattern().c_str();
    
    if (msg->match("/init").isOkNoMoreArgs()){
        
        //Do the local one first (which is only vol)
        /*        float vol = mLocalGetterFunc(NULL, ChorusOsc::kVol)*128.0f;
         
         oscClient.queueMessage(oscClient.newMessage.to("/rate2").add(rate2).end());
         oscClient.queueMessage(oscClient.newMessage.to("/wetdry").add(wetdry).end()); */
        mVSTConsoleMsg.write(String("Initialize Received! \n"));
    } else if (msg->match("/sensel")){
        
        int timeStamp;
        int fingerCount;
        msg->match("/sensel").popInt32(timeStamp).popInt32(fingerCount);
        
        //Let's get the playback sample time
        //Stamp sample position
        AudioPlayHead* track = getPlayHead();
        AudioPlayHead::CurrentPositionInfo trackState;
        track->getCurrentPosition(trackState);
        
        if (mlogEnabled){ //start log entry
            mLogFile << "[R] S: " << trackState.timeInSamples << " R: " << timeStamp << " #C: " << fingerCount;
        }
    }
    
    return;
}

//==============================================================================
SenselVapbiAudioProcessor::SenselVapbiAudioProcessor(){
      // default value
    
    addParameter(f1_plate = new AudioParameterFloat("f1_plateSl",
                                                    "FundFreqPlate Min",
                                                    NormalisableRange<float>(1.0f, MAX_FUND_FREQ_PLATE, 0.0, 0.5, true),
                                                    minf1_plate));
    addParameter(f1_plate_range = new AudioParameterFloat("f1_plateRange_Sl",
                                                    "FundFreqPlate Bend Range",
                                                    NormalisableRange<float>(0.0f, 12.0f, 0.0, 0.5, true),
                                                          mF1_plateRange));
    addParameter(sigma0_plate = new AudioParameterFloat("sigma0_plateSl",
                                                        "Sigma0Plate Min",
                                                        NormalisableRange<float>(0.01f, 1.0f, 0.0, 0.5, false),
                                                        minSigma0));
    addParameter(sigma0_plate_range = new AudioParameterFloat("sigma0_plate_range_Sl",
                                                        "Sigma0Plate Deviation Range",
                                                        NormalisableRange<float>(0.01f, 1.0f, 0.0, 0.5, false),
                                                        mSigma0Range));
    addParameter(sigma1_plate = new AudioParameterFloat("sigma1_plateSl",
                                                        "Sigma1Plate Min",
                                                        NormalisableRange<float>(0.0035f, 1.0f, 0.0, 0.5, false),
                                                        minSigma1));
    addParameter(sigma1_plate_range = new AudioParameterFloat("sigma1_plateRange_Sl",
                                                    "Sigma1Plate Deviation Range",
                                                    NormalisableRange<float>(0.0035f, 1.0f, 0.0, 0.5, false),
                                                    mSigma1Range));

    //==============================================================================
    
/*    addParameter(lpF0Param = new AudioParameterFloat("lpF0_Sl",
                                                        "Low Pass F0 (F0 > 50 defaults)",
                                                        NormalisableRange<float>(0.00001f, 62.50f, 0.0, 0.5, false),
                                                        mLpF0));
    addParameter(lpDampCutParam = new AudioParameterFloat("lpDC_Sl",
                                                          "Low Pass Damp Cutoff",
                                                          NormalisableRange<float>(0.00001f, 1.0f, 0.0, 0.5, false),
                                                          mLpDampCutoff));
    addParameter(hpDampCutParam = new AudioParameterFloat("hpdc_Sl",
                                                          "High Pass Damp Cutoff",
                                                          NormalisableRange<float>(0.00001f, 1.0f, 0.0, 0.5, false),
                                                          mHpDampCutoff));
    addParameter(hpF0Param = new AudioParameterFloat("hpF0_sl",
                                                        "High Pass F0 (F0 > 50 defaults)",
                                                        NormalisableRange<float>(0.00001f, 62.50f, 0.0, 0.5, false),
                                                        mHpF0));
    addParameter(hpQParam = new AudioParameterFloat("hpQ_Sl",
                                                        "High Pass Q ",
                                                        NormalisableRange<float>(0.005f, 1.0f, 0.0, 0.5, false),
                                                        mHpQ));
*/
    //==============================================================================
    // For compatibility with editor, choice Parameters must be added second and update numCombos in pluginEditor.h
    
    addParameter(participantNumParam = new AudioParameterChoice("ParticipantID_CB", "Participant ID Number", {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"}, prevParticipantNum, "Select participant ID number"));
    
    addParameter(sessionNumParam = new AudioParameterChoice("sessionNum_CB", "Session Number", {"1", "2", "3"}, prevTrialNum, "Select session number."));

    addParameter(trialNumParam = new AudioParameterChoice("trialNum_CB", "Trial Number", {"1", "2", "3", "4", "5", "6"}, prevTrialNum, "Select trial number."));
    
    addParameter(dampStyleParam = new AudioParameterChoice("dampStyle_CB", "Damp Style", {"off", "sum", "average", "inverse sum"}, prevDampStyle, "Select damp style."));

    addParameter(freqStyleParam = new AudioParameterChoice("freqStyle_CB", "Frequency Bend Style", {"off", "sum", "average", "inverse sum"}, prevFreqStyle, "Select force input style to modify plate frequency."));


    //==============================================================================
    
    mOscSend.setup(OSC_REMOTE_PORT, OSC_REMOTE_ADDRESS);
    mOscSend.enable(true);  //turned off for now
    
//        void setup(int port, std::function<void(oscpkt::Message* msg, void* arg)> _on_receive, void* callbackArg = nullptr);
    
//    if (mOscRecieve.setup(OSC_LOCAL_PORT, [this](oscpkt::Message *msg, void* arg){this->parseMessage(msg, arg);})) {
//        mVSTConsoleMsg.write(String("Osc receiving on port: ") + String(OSC_LOCAL_PORT) + String("\n"));
//    } else {
//        mVSTConsoleMsg.write(String("ERROR: Failed to open OSC receive port!\n"));
//    }
    
    //-12*log10((float)aref/pitch)*L2SC;
    
    mVerbose = kSilent_Verbose;
    mlogEnabled = false;


    dataTimer = std::chrono::steady_clock::now();
    timerRunning = false;
    
    mDataToAudio = std::unique_ptr<DataAsAudio>(new DataAsAudio(SIZE_DATA_AUDIO_BLOCK));
    
    for (int i = 0; i < amountOfSensels; i++)
        sensels.add(new Sensel(i)); // chooses the device in the sensel device list
    
    if (sensels.size() > 0){ //could do this within sensels, but for now..
        sensels[0]->setLPCoefs({0.097631, 0.195262, 0.097631, -0.942809, 0.333333});
        sensels[0]->setHPCoefs({0.569036, -1.138071, 0.569036, -0.942809, 0.333333});
    }
    numSenselSamples = 0;
}

SenselVapbiAudioProcessor::~SenselVapbiAudioProcessor()
{
    stopTimer();

    if (mLogFile.is_open()){
        if (mVerbose >= kDebug_Verbose){
            mLogFile << "Log file closed in destructor. \n" ;
        }
        mLogFile.close();
    }
}

//==============================================================================
const String SenselVapbiAudioProcessor::getName() const
{
    return JucePlugin_Name;
}
/*
const String SenselVapbiAudioProcessor::getParameterName (int index)
{
    return String();
}

const String SenselVapbiAudioProcessor::getParameterText (int index)
{
    return String();
}
 */

const String SenselVapbiAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String SenselVapbiAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool SenselVapbiAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool SenselVapbiAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool SenselVapbiAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool SenselVapbiAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool SenselVapbiAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double SenselVapbiAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int SenselVapbiAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int SenselVapbiAudioProcessor::getCurrentProgram()
{
    return 0;
}

void SenselVapbiAudioProcessor::setCurrentProgram (int index)
{
}

const String SenselVapbiAudioProcessor::getProgramName (int index)
{
    return String();
}

void SenselVapbiAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void SenselVapbiAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..

    if (gDebug_logging){
        if (openLogFile())
            mlogEnabled = true;
    }
    
    if (mVerbose >= kDebug_Verbose){
        mLogFile << "Entering PrepareToPlay...\n ";
    }
    
    updateTrialInfo();
    mLogFile << "Participant: " << *participantNumParam+1 << " Session: " << *sessionNumParam + 1 << " Trial: " << *trialNumParam+1 << "\n";
    int trial = (*sessionNumParam == 0) ? trialOneSettings[*trialNumParam] : trialThreeSettings[*trialNumParam];
    mLogFile << "Cond: " << trial << " DampStyle: " << *dampStyleParam << " FreqStyle: " << *freqStyleParam << "\n";
    
    //okay, have run some experiments.  Faster than 125, it actually seems to mess things up.  Over 180 it doesn't even seem to run.
    //trying to immediately re-read definitely failed.  125 is lowest frames dropped ~ 3 per second
    // Except running at 512 ...
    if (!timerRunning) { //only starts once now.
        startTimer(1000.0 / 125.0); //faster than 125 actually turns out slower
        timerRunning = true;
    }
    
    mSampleBlockSize = samplesPerBlock;
    mNumMissedFrames = 0; //refresh this count
    
    audioTimer = std::chrono::steady_clock::now();
    localTimeInSamples = 0;
    
    preparedToPlay_ = true;
    
    if (mVerbose >= kDebug_Verbose){
        mLogFile << "Leaving PrepareToPlay...\n ";
    }

}

void SenselVapbiAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void SenselVapbiAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getTotalNumInputChannels(); i < getTotalNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    
    updateTrialInfo();
    
    {
        std::lock_guard<std::mutex> lockGuard(block);
        
        AudioPlayHead* track = getPlayHead();
        AudioPlayHead::CurrentPositionInfo trackState;
        track->getCurrentPosition(trackState);
        
        for (int channel = 0; channel < getTotalNumOutputChannels(); ++channel)
        {
            float* channelData = buffer.getWritePointer (channel);
            
 
            // ..do something to the data...
        }

        //The send keeps state of the last valid send, hence, single channel send only
        mDataToAudio->writeDataToAudio(buffer, trackState.timeInSamples, 1, mSenselData);
        mSenselData.clear();

        std::chrono::steady_clock::time_point nowTime = std::chrono::steady_clock::now();
        chrono::milliseconds ms;
        ms = std::chrono::duration_cast<std::chrono::milliseconds>(nowTime - audioTimer);
        audioTimer = nowTime;
//        mLogFile << " Audio Call! " << trackState.timeInSamples << " AT: " << ms.count() << "\n";

        if (trackState.isPlaying || trackState.isRecording){
            localTimeInSamples = trackState.timeInSamples + buffer.getNumSamples(); //The playhead points to the beginning of the block, not the end, which is actually what we want for the Sensel timing.
        } else {
            localTimeInSamples = trackState.timeInSamples; // if the playhead isn't advancing, don't need to worry about accurate timing.
        }
        
    }

}

//==============================================================================
bool SenselVapbiAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* SenselVapbiAudioProcessor::createEditor()
{
    return new SenselVapbiAudioProcessorEditor (*this);
}

//==============================================================================
void SenselVapbiAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void SenselVapbiAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new SenselVapbiAudioProcessor();
}
