/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#ifndef PLUGINPROCESSOR_H_INCLUDED
#define PLUGINPROCESSOR_H_INCLUDED

#include "../JuceLibraryCode/JuceHeader.h"

#include "SenselWrapper.h"
#include "OscSender.h"
#include "OscReceiver.h"
#include "DataAsAudio.hpp"

#include <iostream>
#include <fstream>
#include <chrono>
#include <vector>

#define NUM_TEST_CONDITIONS 6

//==============================================================================
/**
*/

class VST_Console_String {
    friend class SenselVapbiAudioProcessorEditor; //gui class is the only thing that clears string
    public :
    VST_Console_String(void)        { mSendFlag = false; };
    
    void add(const String& inStr)    { //essentially an append
        std::lock_guard<std::mutex> lockGuard(block);
        mMsg += inStr;
    };
    void write(const String& inStr)    { //append and request immediate send
        std::lock_guard<std::mutex> lockGuard(block);
        mMsg += inStr;
        mSendFlag = true;
    };
    const String& read(void)        { //see what is in the message
        std::lock_guard<std::mutex> lockGuard(block);
        return mMsg;
    };
    void reqSend(void)            {
        std::lock_guard<std::mutex> lockGuard(block);
        mSendFlag = true;
    };        //please send buffer next slot
    
protected:
    void clear(void) {
        std::lock_guard<std::mutex> lockGuard(block);
        mMsg.clear();
    };
    void written(void) {
        std::lock_guard<std::mutex> lockGuard(block);
        mMsg.clear();
        mSendFlag = false;
    };
    
    bool mSendFlag;
    String mMsg;
    
private:
    std::mutex block;
};

//==============================================================================
/**
 */

class SenselVapbiAudioProcessor  : public AudioProcessor, public HighResolutionTimer
{
public:
    
    enum Sensel_Interaction_Parameters{
        kOff = 0,
        kSumForce,
        kAveForce,
        kInverseForce,
        kNumParameters
    };
    
    //==============================================================================
    SenselVapbiAudioProcessor();
    ~SenselVapbiAudioProcessor();

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    void processBlock (AudioSampleBuffer&, MidiBuffer&) override;

    //==============================================================================
    AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const String getName() const override;

//All deprecated I believe
//    int getNumParameters() override;
//    float getParameter (int index) override;
//    void setParameter (int index, float newValue) override;
//    const String getParameterName (int index) override;
//    const String getParameterText (int index) override;

    const String getInputChannelName (int channelIndex) const override;
    const String getOutputChannelName (int channelIndex) const override;
    bool isInputChannelStereoPair (int index) const override;
    bool isOutputChannelStereoPair (int index) const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool silenceInProducesSilenceOut() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const String getProgramName (int index) override;
    void changeProgramName (int index, const String& newName) override;

    //==============================================================================
    void getStateInformation (MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

    //==============================================================================
    //      ADDED BY ME
    void hiResTimerCallback() override;

    void parseMessage(oscpkt::Message* msg, void* arg); //returns number of args
    VST_Console_String * getConsoleData(void) {    return &mVSTConsoleData; }
    VST_Console_String * getConsoleMsg(void) {    return &mVSTConsoleMsg; }
    
    void getTrialOrder(const int inUserNum);
    void getTrialState(const int inTrialNum);
    void updateTrialInfo(void);
    
private:
    // Parameters from Vapbi
    
    AudioParameterFloat* sigma0_plate;  //done
    AudioParameterFloat* sigma0_plate_range;
    AudioParameterFloat* sigma1_plate;  //done
    AudioParameterFloat* sigma1_plate_range;
    AudioParameterFloat* f1_plate;      //not done
    AudioParameterFloat* f1_plate_range;
    
    float minSigma0 = 0.15;
    float mSigma0Range = 1.0f;
    float minSigma1 = .045;
    float mSigma1Range = 1.0f;
    float minf1_plate = 17.7; //this one is direct
    float mF1_plateRange = 12.;
    
    float mEffort = 0.51f;
    float mAveEffort = 10.0f;

    //==============================================================================

    /*
    AudioParameterFloat* lpF0Param;
    AudioParameterFloat* lpQParam;
    AudioParameterFloat* hpF0Param;
    AudioParameterFloat* hpQParam;
    AudioParameterFloat* lpDampCutParam;
    AudioParameterFloat* hpDampCutParam;
    
    float mLpF0 = 3.125;
    float mLpQ = .01;
    float mHpF0 = 31.25;
    float mHpQ = .01;
    float mLpDampCutoff = .015;
    float mHpDampCutoff = .001;
     */
    
    AudioParameterChoice* dampStyleParam;
    AudioParameterChoice* freqStyleParam;

    AudioParameterChoice* participantNumParam;
    AudioParameterChoice* trialNumParam;
    AudioParameterChoice* sessionNumParam;
    
    std::array<int, NUM_TEST_CONDITIONS> trialOneSettings;
    std::array<int, NUM_TEST_CONDITIONS> trialThreeSettings;
    int prevParticipantNum = 1;
    int prevTrialNum = 1;
    int prevSessionNum = 1;
    int prevDampStyle = 1; //this is merely because I want to update my console and it is the easiest way to do it...
    int prevFreqStyle = 1; //this is merely because I want to update my console and it is the easiest way to do it...
    //    AudioParameterFloat* hpDampCutParam;
    
    //==============================================================================

    bool openLogFile(void);

    //==============================================================================

    std::unique_ptr<DataAsAudio> mDataToAudio;
    std::vector<Sensel_Vapbi_Data> mSenselData;
    std::mutex block;
        
    int32 mSampleBlockSize = 256;
    int32 mNumMissedFrames = 0;
    
    OwnedArray<Sensel> sensels;
    const unsigned int amountOfSensels = 1;
    unsigned int numSenselSamples;
    
    Sensel_Vapbi_Data lastSenselData;

//    float lastStrikeX = .5; //default is middle
//    float lastStrikeY = .5; //default is middle
    
    std::chrono::steady_clock::time_point audioTimer;
    std::chrono::steady_clock::time_point dataTimer;
    int64 wasTime;
    int64 localTimeInSamples;
    bool timerRunning;
    
    std::ofstream mLogFile;
    bool    mlogEnabled;
    int     mlogVerbosity;
    int     mVerbose;
    
    OscSender   mOscSend;
//    OscReceiver mOscRecieve;
    
    VST_Console_String    mVSTConsoleMsg; // generally use append with this
    VST_Console_String    mVSTConsoleData; // generally use append with this
    
    // Whether or not prepareToPlay() has been called, i.e. that resources are in use
    bool preparedToPlay_;

    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SenselVapbiAudioProcessor)
    
};


#endif  // PLUGINPROCESSOR_H_INCLUDED
